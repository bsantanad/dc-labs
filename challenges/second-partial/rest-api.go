package main

import (
	"encoding/json"
	"fmt"
	//"io/ioutil"
	"log"
	"net/http"
	"strings"
	"time"
)

type LoginResponse struct {
	Message string `json:"message"`
	Token   string `json:"token"`
}

type User struct {
	Username string `json:"user"`
	Token    string `json:"token"`
	Time     string `json:"time"`
}

type Status struct {
	Message string `json:"message"`
	Time    string `json:"time"`
}

type Message struct {
	Message string `json:"message"`
}

var Users []User /* this will act as our DB */

/********************* Endpoint Functions ***************************/

func homePage(w http.ResponseWriter, r *http.Request) {

	w.WriteHeader(200)
	returnMsg(w, "DPIP REST API index. Invalid enpoints will redirect here")
	fmt.Println("[INFO]: / requested")
}

// postLogin will get the hash that's generated by default
// by the header "Authorization", then it will use it
// as the token for this particular user.
// It will also add the user to the "DB" of users, along
// with it's token
func postLogin(w http.ResponseWriter, r *http.Request) {
	var token string
	var user string
	var tmp string

	fmt.Println("[INFO]: POST /login requested")
	user, _, _ = r.BasicAuth() //get username
	tmp = r.Header.Get("Authorization")
	token = strings.Fields(tmp)[1] // get the hash from header

	//Build response
	var login LoginResponse
	login = LoginResponse{
		Message: "Hi " + user + ", welcome to the DPIP System",
		Token:   token,
	}

	var userInfo User
	userInfo = User{
		Username: user,
		Token:    token,
		Time:     time.Now().UTC().String(),
	}
	Users = append(Users, userInfo)

	json.NewEncoder(w).Encode(login)
}

// delLogout function will revoke a token from being usable.
// first it checks if the headers are sent in the correct
// format, then it will search the token in the Users "DB"
// if found it will remove it, if not, it will return 400
func delLogout(w http.ResponseWriter, r *http.Request) {
	fmt.Println("[INFO]: DELETE /logout requested")
	tmp := r.Header.Get("Authorization")
	if strings.Fields(tmp)[0] != "Bearer" {
		w.WriteHeader(400)
		returnMsg(w, "bad request, check headers "+
			"you must send a Bearer token")
		return
	}
	token := strings.Fields(tmp)[1] // get the token from header
	index, user, exists := searchToken(token)
	if !exists {
		w.WriteHeader(400)
		returnMsg(w, "token not found, "+
			"please provide a valid one")
		return
	}

	Users = removeUser(Users, index)
	returnMsg(w, "Bye "+user.Username+", your token has been revoked")
}

func postUpload(w http.ResponseWriter, r *http.Request) {
	return
}

// getStatus, show the status of the account related
// to the token sent in the header, proper validations
// are done, and then the creation time, and a msg is
// returned to the user
func getStatus(w http.ResponseWriter, r *http.Request) {
	fmt.Println("[INFO]: GET /status requested")
	tmp := r.Header.Get("Authorization")
	if strings.Fields(tmp)[0] != "Bearer" {
		w.WriteHeader(400)
		returnMsg(w, "bad request, check headers "+
			"you must send a Bearer token")
		return
	}
	token := strings.Fields(tmp)[1] // get the token from header
	_, user, exists := searchToken(token)
	if !exists {
		w.WriteHeader(400)
		returnMsg(w, "token not found, "+
			"please provide a valid one")
		return
	}

	var status Status
	status = Status{
		Message: "Hi " + user.Username + ", the DPIP System is Up and Running",
		Time:    user.Time,
	}

	json.NewEncoder(w).Encode(status)
}

/********************* Handler Functions ***************************/

func handleLogin(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodPost:
		postLogin(w, r) // post
	case http.MethodPut:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodDelete:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	default:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	}

}
func handleLogout(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodPost:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodPut:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodDelete:
		delLogout(w, r) // delete
	default:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	}

}
func handleUpload(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodPost:
		postUpload(w, r) // post
	case http.MethodPut:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodDelete:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	default:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	}

}

func handleStatus(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		getStatus(w, r) //get
	case http.MethodPost:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodPut:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	case http.MethodDelete:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	default:
		w.WriteHeader(404)
		returnMsg(w, "page not found")
	}

}

func handleRequests() {
	http.HandleFunc("/", homePage)
	http.HandleFunc("/login", handleLogin)
	http.HandleFunc("/logout", handleLogout)
	http.HandleFunc("/upload", handleUpload)
	http.HandleFunc("/status", handleStatus)
	log.Fatal(http.ListenAndServe(":8080", nil))
}

/********************* Helper Functions ***************************/

// Search token in Users, returned index, user struct
// and boolean that tells us if it was found.
func searchToken(token string) (int, User, bool) {
	for i, user := range Users {
		if user.Token == token {
			return i, user, true
		}
	}
	var tmp User
	return -1, tmp, false
}

// swap the user you want to remove with the
// last item, return the slice without the last item
func removeUser(users []User, index int) []User {
	users[index] = users[len(users)-1]
	return users[:len(users)-1]
}

func returnMsg(w http.ResponseWriter, msg string) {
	var msgJSON Message
	msgJSON = Message{
		Message: msg,
	}
	json.NewEncoder(w).Encode(msgJSON)

}

func main() {
	handleRequests()
}
